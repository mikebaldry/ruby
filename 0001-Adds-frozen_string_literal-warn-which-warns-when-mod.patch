From 29f6fbfe3b5ac4a4ed53c7b30cbb80269b273fb0 Mon Sep 17 00:00:00 2001
From: Michael Baldry <michael@brightbits.co.uk>
Date: Thu, 6 Jun 2024 13:30:31 +0000
Subject: [PATCH] Adds '# frozen_string_literal: warn' which warns when
 modifying a string that would be frozen, if the file had `#
 frozen_string_literal: true`.

---
 compile.c               | 19 ++++++++---
 defs/id.def             |  1 +
 insns.def               |  5 +++
 iseq.c                  | 10 ++++--
 iseq.h                  |  2 +-
 mini_builtin.c          |  2 +-
 parse.y                 | 28 ++++++++++++----
 rubyparser.h            |  2 +-
 string.c                | 74 +++++++++++++++++++++++++++++++++++++++--
 template/prelude.c.tmpl |  2 +-
 10 files changed, 125 insertions(+), 20 deletions(-)

diff --git a/compile.c b/compile.c
index 3c92729760..7ffecdaccf 100644
--- a/compile.c
+++ b/compile.c
@@ -4652,7 +4652,7 @@ static_literal_node_p(const NODE *node, const rb_iseq_t *iseq)
       case NODE_FALSE:
         return TRUE;
       case NODE_STR:
-        return ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal;
+        return ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal == 1;
       default:
         return FALSE;
     }
@@ -8317,7 +8317,7 @@ compile_call_precheck_freeze(rb_iseq_t *iseq, LINK_ANCHOR *const ret, const NODE
         nd_type_p(get_nd_args(node), NODE_LIST) && RNODE_LIST(get_nd_args(node))->as.nd_alen == 1 &&
         nd_type_p(RNODE_LIST(get_nd_args(node))->nd_head, NODE_STR) &&
         ISEQ_COMPILE_DATA(iseq)->current_block == NULL &&
-        !ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal &&
+        ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal != 1 &&
         ISEQ_COMPILE_DATA(iseq)->option->specialized_instruction) {
         VALUE str = rb_fstring(RNODE_STR(RNODE_LIST(get_nd_args(node))->nd_head)->nd_lit);
         CHECK(COMPILE(ret, "recv", get_nd_recv(node)));
@@ -9664,7 +9664,7 @@ compile_attrasgn(rb_iseq_t *iseq, LINK_ANCHOR *const ret, const NODE *const node
         nd_type_p(RNODE_ATTRASGN(node)->nd_args, NODE_LIST) && RNODE_LIST(RNODE_ATTRASGN(node)->nd_args)->as.nd_alen == 2 &&
         nd_type_p(RNODE_LIST(RNODE_ATTRASGN(node)->nd_args)->nd_head, NODE_STR) &&
         ISEQ_COMPILE_DATA(iseq)->current_block == NULL &&
-        !ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal &&
+        ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal != 1 &&
         ISEQ_COMPILE_DATA(iseq)->option->specialized_instruction)
     {
         VALUE str = rb_fstring(RNODE_STR(RNODE_LIST(RNODE_ATTRASGN(node)->nd_args)->nd_head)->nd_lit);
@@ -10097,8 +10097,17 @@ iseq_compile_each0(rb_iseq_t *iseq, LINK_ANCHOR *const ret, const NODE *const no
         debugp_param("nd_lit", RNODE_STR(node)->nd_lit);
         if (!popped) {
             VALUE lit = RNODE_STR(node)->nd_lit;
-            if (!ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal) {
-                lit = rb_fstring(lit);
+
+            if (ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal != 1) {
+                if (ISEQ_COMPILE_DATA(iseq)->option->frozen_string_literal == -2) {
+                    VALUE created_info = rb_ary_new_from_args(2, rb_iseq_path(iseq), INT2FIX(line));
+                    lit = rb_str_dup(lit);
+                    FL_SET(lit, FL_USER0);
+                    rb_ivar_set(lit, id_warn_frozen_string_literal_created_info, rb_obj_freeze(created_info));
+                } else {
+                    lit = rb_fstring(lit);
+                }
+
                 ADD_INSN1(ret, node, putstring, lit);
                 RB_OBJ_WRITTEN(iseq, Qundef, lit);
             }
diff --git a/defs/id.def b/defs/id.def
index 2ddde7be70..8728950ca6 100644
--- a/defs/id.def
+++ b/defs/id.def
@@ -93,6 +93,7 @@ firstline, predefined = __LINE__+1, %[\
   core#sprintf
 
   -                                                     debug#created_info
+  -                                                     warn#frozen_string_literal_created_info
 
   $_                                                    LASTLINE
   $~                                                    BACKREF
diff --git a/insns.def b/insns.def
index 5f6cb314ff..96e3836b40 100644
--- a/insns.def
+++ b/insns.def
@@ -376,6 +376,11 @@ putstring
 (VALUE val)
 {
     val = rb_ec_str_resurrect(ec, str);
+    VALUE created_info;
+    if (FL_TEST(str, FL_USER0) && !NIL_P(created_info = rb_attr_get(str, id_warn_frozen_string_literal_created_info))) {
+        rb_ivar_set(val, id_warn_frozen_string_literal_created_info, created_info);
+        FL_SET(val, FL_USER0);
+    }
 }
 
 /* put concatenate strings */
diff --git a/iseq.c b/iseq.c
index 27c5bb5d82..536528eca0 100644
--- a/iseq.c
+++ b/iseq.c
@@ -753,7 +753,7 @@ set_compile_option_from_hash(rb_compile_option_t *option, VALUE opt)
     SET_COMPILE_OPTION(option, opt, specialized_instruction);
     SET_COMPILE_OPTION(option, opt, operands_unification);
     SET_COMPILE_OPTION(option, opt, instructions_unification);
-    SET_COMPILE_OPTION(option, opt, frozen_string_literal);
+    SET_COMPILE_OPTION_NUM(option, opt, frozen_string_literal);
     SET_COMPILE_OPTION(option, opt, debug_frozen_string_literal);
     SET_COMPILE_OPTION(option, opt, coverage_enabled);
     SET_COMPILE_OPTION_NUM(option, opt, debug_level);
@@ -766,9 +766,13 @@ set_compile_option_from_ast(rb_compile_option_t *option, const rb_ast_body_t *as
 {
 #define SET_COMPILE_OPTION(o, a, mem) \
     ((a)->mem < 0 ? 0 : ((o)->mem = (a)->mem > 0))
-    SET_COMPILE_OPTION(option, ast, frozen_string_literal);
+#define SET_COMPILE_OPTION_NUM(o, a, mem) \
+    ((o)->mem = (a)->mem)
+
+    SET_COMPILE_OPTION_NUM(option, ast, frozen_string_literal);
     SET_COMPILE_OPTION(option, ast, coverage_enabled);
 #undef SET_COMPILE_OPTION
+#undef SET_COMPILE_OPTION_NUM
     return option;
 }
 
@@ -810,7 +814,7 @@ make_compile_option_value(rb_compile_option_t *option)
         SET_COMPILE_OPTION(option, opt, specialized_instruction);
         SET_COMPILE_OPTION(option, opt, operands_unification);
         SET_COMPILE_OPTION(option, opt, instructions_unification);
-        SET_COMPILE_OPTION(option, opt, frozen_string_literal);
+        SET_COMPILE_OPTION_NUM(option, opt, frozen_string_literal);
         SET_COMPILE_OPTION(option, opt, debug_frozen_string_literal);
         SET_COMPILE_OPTION(option, opt, coverage_enabled);
         SET_COMPILE_OPTION_NUM(option, opt, debug_level);
diff --git a/iseq.h b/iseq.h
index d71f37ca13..8707d5b7ce 100644
--- a/iseq.h
+++ b/iseq.h
@@ -229,7 +229,7 @@ struct rb_compile_option_struct {
     unsigned int specialized_instruction: 1;
     unsigned int operands_unification: 1;
     unsigned int instructions_unification: 1;
-    unsigned int frozen_string_literal: 1;
+    signed int frozen_string_literal: 2;
     unsigned int debug_frozen_string_literal: 1;
     unsigned int coverage_enabled: 1;
     int debug_level;
diff --git a/mini_builtin.c b/mini_builtin.c
index 457327ee06..4c952e6659 100644
--- a/mini_builtin.c
+++ b/mini_builtin.c
@@ -35,7 +35,7 @@ builtin_iseq_load(const char *feature_name, const struct rb_builtin_function *ta
         TRUE, /* unsigned int specialized_instruction; */
         TRUE, /* unsigned int operands_unification; */
         TRUE, /* unsigned int instructions_unification; */
-        TRUE, /* unsigned int frozen_string_literal; */
+        1, /* signed int frozen_string_literal; */
         FALSE, /* unsigned int debug_frozen_string_literal; */
         FALSE, /* unsigned int coverage_enabled; */
         0, /* int debug_level; */
diff --git a/parse.y b/parse.y
index 8755904b9a..532f1413a0 100644
--- a/parse.y
+++ b/parse.y
@@ -495,7 +495,7 @@ struct parser_params {
     rb_parser_config_t *config;
 #endif
     /* compile_option */
-    signed int frozen_string_literal:2; /* -1: not specified, 0: false, 1: true */
+    signed int frozen_string_literal:2; /* -2: warn, -1: not specified, 0: false, 1: true */
 
     unsigned int command_start:1;
     unsigned int eofp: 1;
@@ -9315,17 +9315,33 @@ parser_set_token_info(struct parser_params *p, const char *name, const char *val
 static void
 parser_set_frozen_string_literal(struct parser_params *p, const char *name, const char *val)
 {
-    int b;
-
     if (p->token_seen) {
         rb_warning1("`%s' is ignored after any tokens", WARN_S(name));
         return;
     }
 
-    b = parser_get_bool(p, name, val);
-    if (b < 0) return;
+    switch (*val) {
+      case 't': case 'T':
+        if (STRCASECMP(val, "true") == 0) {
+            p->frozen_string_literal = 1;
+            return;
+        }
+        break;
+      case 'f': case 'F':
+        if (STRCASECMP(val, "false") == 0) {
+            p->frozen_string_literal = 0;
+            return;
+        }
+        break;
+      case 'w': case 'W':
+        if (STRCASECMP(val, "warn") == 0) {
+            p->frozen_string_literal = -2;
+            return;
+        }
+        break;
+    }
 
-    p->frozen_string_literal = b;
+    p->frozen_string_literal = parser_invalid_pragma_value(p, name, val);
 }
 
 static void
diff --git a/rubyparser.h b/rubyparser.h
index 47b3b9c10b..2fe1842c4f 100644
--- a/rubyparser.h
+++ b/rubyparser.h
@@ -1090,7 +1090,7 @@ typedef struct rb_ast_body_struct {
     // script_lines is either:
     // - a Fixnum that represents the line count of the original source, or
     // - an Array that contains the lines of the original source
-    signed int frozen_string_literal:2; /* -1: not specified, 0: false, 1: true */
+    signed int frozen_string_literal:2; /* -2: warn, -1: not specified, 0: false, 1: true */
     signed int coverage_enabled:2; /* -1: not specified, 0: false, 1: true */
 } rb_ast_body_t;
 typedef struct rb_ast_struct {
diff --git a/string.c b/string.c
index 3d4650ff05..c5e31bfaea 100644
--- a/string.c
+++ b/string.c
@@ -38,6 +38,7 @@
 #include "internal/sanitizers.h"
 #include "internal/string.h"
 #include "internal/transcode.h"
+# include "internal/variable.h"
 #include "probes.h"
 #include "ruby/encoding.h"
 #include "ruby/re.h"
@@ -1749,6 +1750,8 @@ str_duplicate_setup(VALUE klass, VALUE str, VALUE dup)
     }
     FL_SET_RAW(dup, flags & ~FL_FREEZE);
     if (encidx) rb_enc_associate_index(dup, encidx);
+    FL_UNSET(dup, FL_USER0);
+
     return dup;
 }
 
@@ -1793,8 +1796,15 @@ rb_str_dup_m(VALUE str)
     if (LIKELY(BARE_STRING_P(str))) {
         return str_duplicate(rb_obj_class(str), str);
     }
+    else if (FL_TEST(str, FL_USER0) && RBASIC_CLASS(str) == rb_cString && rb_ivar_count(str) == 1) {
+        return str_duplicate(rb_obj_class(str), str);
+    }
     else {
-        return rb_obj_dup(str);
+        VALUE result = rb_obj_dup(str);
+        if (FL_TEST(str, FL_USER0)) {
+            rb_attr_delete(result, id_warn_frozen_string_literal_created_info);
+        }
+        return result;
     }
 }
 
@@ -2420,6 +2430,14 @@ rb_check_lockedtmp(VALUE str)
     }
 }
 
+#define check_frozen_string_literal_warn(meth, str) \
+    ({VALUE created_info; \
+    if (FL_TEST(str, FL_USER0) && !NIL_P(created_info = rb_attr_get(str, id_warn_frozen_string_literal_created_info))) { \
+        VALUE path = rb_ary_entry(created_info, 0); \
+        VALUE line = rb_ary_entry(created_info, 1); \
+        rb_warn("'%s' called on a string that could, in the future be frozen. string created at %"PRIsVALUE":%"PRIsVALUE, meth, path, line); \
+    }})
+
 static inline void
 str_modifiable(VALUE str)
 {
@@ -3522,6 +3540,8 @@ rb_str_concat(VALUE str1, VALUE str2)
         return rb_str_append(str1, str2);
     }
 
+    check_frozen_string_literal_warn("concat", str1);
+
     encidx = rb_ascii8bit_appendable_encoding_index(enc, code);
     if (encidx >= 0) {
         char buf[1];
@@ -5509,6 +5529,8 @@ rb_str_aset(VALUE str, VALUE indx, VALUE val)
 static VALUE
 rb_str_aset_m(int argc, VALUE *argv, VALUE str)
 {
+    check_frozen_string_literal_warn("[]=", str);
+
     if (argc == 3) {
         if (RB_TYPE_P(argv[0], T_REGEXP)) {
             rb_str_subpat_set(str, argv[0], argv[1], argv[2]);
@@ -5543,6 +5565,8 @@ rb_str_aset_m(int argc, VALUE *argv, VALUE str)
 static VALUE
 rb_str_insert(VALUE str, VALUE idx, VALUE str2)
 {
+    check_frozen_string_literal_warn("insert", str);
+
     long pos = NUM2LONG(idx);
 
     if (pos == -1) {
@@ -5587,6 +5611,9 @@ rb_str_slice_bang(int argc, VALUE *argv, VALUE str)
     char *p;
 
     rb_check_arity(argc, 1, 2);
+
+    check_frozen_string_literal_warn("slice!", str);
+
     str_modify_keep_cr(str);
     indx = argv[0];
     if (RB_TYPE_P(indx, T_REGEXP)) {
@@ -5770,6 +5797,8 @@ rb_str_sub_bang(int argc, VALUE *argv, VALUE str)
         }
     }
 
+    check_frozen_string_literal_warn("sub!", str);
+
     pat = get_pat_quoted(argv[0], 1);
 
     str_modifiable(str);
@@ -6026,6 +6055,7 @@ str_gsub(int argc, VALUE *argv, VALUE str, int bang)
 static VALUE
 rb_str_gsub_bang(int argc, VALUE *argv, VALUE str)
 {
+    check_frozen_string_literal_warn("gsub!", str);
     str_modify_keep_cr(str);
     return str_gsub(argc, argv, str, 1);
 }
@@ -6069,6 +6099,21 @@ VALUE
 rb_str_replace(VALUE str, VALUE str2)
 {
     str_modifiable(str);
+
+    if (str == str2) return str;
+
+    StringValue(str2);
+    str_discard(str);
+    return str_replace(str, str2);
+}
+
+VALUE
+rb_str_replace_user(VALUE str, VALUE str2)
+{
+    check_frozen_string_literal_warn("replace", str);
+
+    str_modifiable(str);
+
     if (str == str2) return str;
 
     StringValue(str2);
@@ -6090,6 +6135,7 @@ rb_str_replace(VALUE str, VALUE str2)
 static VALUE
 rb_str_clear(VALUE str)
 {
+    check_frozen_string_literal_warn("clear", str);
     str_discard(str);
     STR_SET_EMBED(str);
     STR_SET_LEN(str, 0);
@@ -6174,6 +6220,8 @@ rb_str_setbyte(VALUE str, VALUE index, VALUE value)
     VALUE w = rb_int_and(v, INT2FIX(0xff));
     char byte = (char)(NUM2INT(w) & 0xFF);
 
+    check_frozen_string_literal_warn("setbyte", str);
+
     if (!str_independent(str))
         str_make_independent(str);
     enc = STR_ENC_GET(str);
@@ -6426,6 +6474,7 @@ rb_str_bytesplice(int argc, VALUE *argv, VALUE str)
     str_check_beg_len(str, &beg, &len);
     str_check_beg_len(val, &vbeg, &vlen);
     enc = rb_enc_check(str, val);
+    check_frozen_string_literal_warn("bytesplice", str);
     str_modify_keep_cr(str);
     rb_str_update_1(str, beg, len, val, vbeg, vlen);
     rb_enc_associate(str, enc);
@@ -6515,6 +6564,7 @@ rb_str_reverse_bang(VALUE str)
         if (single_byte_optimizable(str)) {
             char *s, *e, c;
 
+            check_frozen_string_literal_warn("reverse!", str);
             str_modify_keep_cr(str);
             s = RSTRING_PTR(str);
             e = RSTRING_END(str) - 1;
@@ -7532,6 +7582,7 @@ rb_str_upcase_bang(int argc, VALUE *argv, VALUE str)
     OnigCaseFoldType flags = ONIGENC_CASE_UPCASE;
 
     flags = check_case_options(argc, argv, flags);
+    check_frozen_string_literal_warn("upcase!", str);
     str_modify_keep_cr(str);
     enc = str_true_enc(str);
     if (case_option_single_p(flags, enc, str)) {
@@ -7634,6 +7685,7 @@ rb_str_downcase_bang(int argc, VALUE *argv, VALUE str)
     OnigCaseFoldType flags = ONIGENC_CASE_DOWNCASE;
 
     flags = check_case_options(argc, argv, flags);
+    check_frozen_string_literal_warn("downcase!", str);
     str_modify_keep_cr(str);
     enc = str_true_enc(str);
     if (case_option_single_p(flags, enc, str)) {
@@ -7719,6 +7771,7 @@ rb_str_capitalize_bang(int argc, VALUE *argv, VALUE str)
     OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_TITLECASE;
 
     flags = check_case_options(argc, argv, flags);
+    check_frozen_string_literal_warn("capitalize!", str);
     str_modify_keep_cr(str);
     enc = str_true_enc(str);
     if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
@@ -7798,6 +7851,7 @@ rb_str_swapcase_bang(int argc, VALUE *argv, VALUE str)
     OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE;
 
     flags = check_case_options(argc, argv, flags);
+    check_frozen_string_literal_warn("swapcase!", str);
     str_modify_keep_cr(str);
     enc = str_true_enc(str);
     if (flags&ONIGENC_CASE_ASCII_ONLY)
@@ -8173,6 +8227,7 @@ tr_trans(VALUE str, VALUE src, VALUE repl, int sflag)
 static VALUE
 rb_str_tr_bang(VALUE str, VALUE src, VALUE repl)
 {
+    check_frozen_string_literal_warn("tr!", str);
     return tr_trans(str, src, repl, 0);
 }
 
@@ -8341,6 +8396,7 @@ rb_str_delete_bang(int argc, VALUE *argv, VALUE str)
         tr_setup_table(s, squeez, i==0, &del, &nodel, enc);
     }
 
+    check_frozen_string_literal_warn("delete!", str);
     str_modify_keep_cr(str);
     ascompat = rb_enc_asciicompat(enc);
     s = t = RSTRING_PTR(str);
@@ -8440,6 +8496,7 @@ rb_str_squeeze_bang(int argc, VALUE *argv, VALUE str)
         }
     }
 
+    check_frozen_string_literal_warn("squeeze!", str);
     str_modify_keep_cr(str);
     s = t = (unsigned char *)RSTRING_PTR(str);
     if (!s || RSTRING_LEN(str) == 0) return Qnil;
@@ -8529,6 +8586,8 @@ rb_str_squeeze(int argc, VALUE *argv, VALUE str)
 static VALUE
 rb_str_tr_s_bang(VALUE str, VALUE src, VALUE repl)
 {
+    check_frozen_string_literal_warn("tr_s!", str);
+
     return tr_trans(str, src, repl, 1);
 }
 
@@ -9577,6 +9636,7 @@ chopped_length(VALUE str)
 static VALUE
 rb_str_chop_bang(VALUE str)
 {
+    check_frozen_string_literal_warn("chop!", str);
     str_modify_keep_cr(str);
     if (RSTRING_LEN(str) > 0) {
         long len;
@@ -9758,6 +9818,8 @@ rb_str_chomp_bang(int argc, VALUE *argv, VALUE str)
 {
     VALUE rs;
     str_modifiable(str);
+    check_frozen_string_literal_warn("chomp!", str);
+
     if (RSTRING_LEN(str) == 0 && argc < 2) return Qnil;
     rs = chomp_rs(argc, argv);
     if (NIL_P(rs)) return Qnil;
@@ -9821,6 +9883,7 @@ rb_str_lstrip_bang(VALUE str)
     char *start, *s;
     long olen, loffset;
 
+    check_frozen_string_literal_warn("lstrip!", str);
     str_modify_keep_cr(str);
     enc = STR_ENC_GET(str);
     RSTRING_GETMEM(str, start, olen);
@@ -9909,6 +9972,7 @@ rb_str_rstrip_bang(VALUE str)
     char *start;
     long olen, roffset;
 
+    check_frozen_string_literal_warn("rstrip!", str);
     str_modify_keep_cr(str);
     enc = STR_ENC_GET(str);
     RSTRING_GETMEM(str, start, olen);
@@ -9972,6 +10036,7 @@ rb_str_strip_bang(VALUE str)
     long olen, loffset, roffset;
     rb_encoding *enc;
 
+    check_frozen_string_literal_warn("strip!", str);
     str_modify_keep_cr(str);
     enc = STR_ENC_GET(str);
     RSTRING_GETMEM(str, start, olen);
@@ -10766,6 +10831,7 @@ static VALUE
 rb_str_delete_prefix_bang(VALUE str, VALUE prefix)
 {
     long prefixlen;
+    check_frozen_string_literal_warn("delete_prefix!", str);
     str_modify_keep_cr(str);
 
     prefixlen = deleted_prefix_length(str, prefix);
@@ -10842,6 +10908,7 @@ rb_str_delete_suffix_bang(VALUE str, VALUE suffix)
 {
     long olen, suffixlen, len;
     str_modifiable(str);
+    check_frozen_string_literal_warn("delete_suffix!", str);
 
     suffixlen = deleted_suffix_length(str, suffix);
     if (suffixlen <= 0) return Qnil;
@@ -10913,6 +10980,7 @@ static VALUE
 rb_str_force_encoding(VALUE str, VALUE enc)
 {
     str_modifiable(str);
+    check_frozen_string_literal_warn("force_encoding", str);
 
     rb_encoding *encoding = rb_to_encoding(enc);
     int idx = rb_enc_to_index(encoding);
@@ -11361,6 +11429,7 @@ str_scrub(int argc, VALUE *argv, VALUE str)
 static VALUE
 str_scrub_bang(int argc, VALUE *argv, VALUE str)
 {
+    check_frozen_string_literal_warn("scrub!", str);
     VALUE repl = argc ? (rb_check_arity(argc, 0, 1), argv[0]) : Qnil;
     VALUE new = rb_str_scrub(str, repl);
     if (!NIL_P(new)) rb_str_replace(str, new);
@@ -11438,6 +11507,7 @@ rb_str_unicode_normalize(int argc, VALUE *argv, VALUE str)
 static VALUE
 rb_str_unicode_normalize_bang(int argc, VALUE *argv, VALUE str)
 {
+    check_frozen_string_literal_warn("unicode_normalize!", str);
     return rb_str_replace(str, unicode_normalize_common(argc, argv, str, id_normalize));
 }
 
@@ -12147,7 +12217,7 @@ Init_String(void)
     rb_define_method(rb_cString, "byteindex", rb_str_byteindex_m, -1);
     rb_define_method(rb_cString, "rindex", rb_str_rindex_m, -1);
     rb_define_method(rb_cString, "byterindex", rb_str_byterindex_m, -1);
-    rb_define_method(rb_cString, "replace", rb_str_replace, 1);
+    rb_define_method(rb_cString, "replace", rb_str_replace_user, 1);
     rb_define_method(rb_cString, "clear", rb_str_clear, 0);
     rb_define_method(rb_cString, "chr", rb_str_chr, 0);
     rb_define_method(rb_cString, "getbyte", rb_str_getbyte, 1);
diff --git a/template/prelude.c.tmpl b/template/prelude.c.tmpl
index 74f6c08da7..20afdb7efb 100644
--- a/template/prelude.c.tmpl
+++ b/template/prelude.c.tmpl
@@ -190,7 +190,7 @@ prelude_eval(VALUE code, VALUE name, int line)
         TRUE, /* unsigned int specialized_instruction; */
         TRUE, /* unsigned int operands_unification; */
         TRUE, /* unsigned int instructions_unification; */
-        TRUE, /* unsigned int frozen_string_literal; */
+        0, /* signed int frozen_string_literal; */
         FALSE, /* unsigned int debug_frozen_string_literal; */
         FALSE, /* unsigned int coverage_enabled; */
         0, /* int debug_level; */
-- 
2.40.1

